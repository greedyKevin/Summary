### volatile

* 保证了不同线程对这个变量的可见性
* 禁止重排序
* 修改的值强制写入主存
* t1修改时，t2的值无效
* t2的值无效，重读

**不能保证原子性**

#### 实现原理

在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

（2）它会强制将对缓存的修改操作立即写入主存；

（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

![image-20220327164632570](C:\Users\Kkkkg\AppData\Roaming\Typora\typora-user-images\image-20220327164632570.png)

内存屏障（[memory barrier](http://en.wikipedia.org/wiki/Memory_barrier)）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。

- 当A,B线程同时读时，读屏障已完成。
- 自增
- 写回主存，只增加了一次

### JMM模型

![20180613171711160](https://img-blog.csdn.net/20180613171711160)

